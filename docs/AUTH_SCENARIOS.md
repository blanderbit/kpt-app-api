## Сценарии авторизации и регистрации

Документ описывает четыре основных сценария работы с аккаунтом:

- регистрация по email/паролю;
- регистрация через соцсети (через Firebase ID token);
- вход по email/паролю;
- вход через соцсети (через Firebase ID token).

Описание намеренно обобщённое, чтобы его можно было использовать как ориентир в любом проекте с похожей архитектурой.

---

### 1. Регистрация: email + пароль

**Цель:** создать нового пользователя, собрать первичные данные и отправить письмо для подтверждения email.

**Последовательность:**

1. **Клиент** отправляет форму регистрации на backend:
   - email;
   - пароль;
   - имя / базовые поля профиля;
   - ответы онбординга (если есть);
   - стартовые активности (если есть);
   - дополнительные поля (настроение, способ трекинга задач и т.п.).
2. **Бэкенд** проверяет, что пользователя с таким email ещё нет.  
   Если email занят — возвращает ошибку «пользователь уже существует».
3. Пароль **хэшируется** (bcrypt или аналог) и **никогда не сохраняется в открытом виде**.
4. Создаётся запись пользователя в БД:
   - email;
   - passwordHash;
   - основные поля профиля;
   - `emailVerified = false`;
   - роли по умолчанию (обычно `user`);
   - мета‑информация (например, онбординг) сохраняется в отдельном поле/JSON.
5. Генерируется **код/токен для подтверждения email**, который сохраняется в отдельной таблице/коллекции, привязывается к пользователю и имеет срок жизни.
6. Через почтовый сервис отправляется **письмо подтверждения** с этим кодом/токеном (или ссылкой).
7. При необходимости добавляются стартовые записи (например, стартовые активности).
8. В ответе клиент получает:
   - сообщение о том, что регистрация прошла успешно;
   - идентификатор пользователя (если нужно связать с внешними системами подписок и т.п.).

**Подтверждение email:**

1. Клиент передаёт код/токен из письма на backend.
2. Бэкенд проверяет наличие и срок действия кода.
3. Если всё ок:
   - помечает код использованным;
   - обновляет у пользователя `emailVerified = true`.

---

### 2. Регистрация: через соцсети (Firebase / OAuth)

**Цель:** создать пользователя, использующего учётную запись внешнего провайдера (Google / Apple и т.п.), без локального пароля, но с тем же онбордингом и стартовыми данными.

**Высокоуровневый поток:**

1. **Клиент** (мобильное или веб-приложение) выполняет вход во внешнего провайдера (через Firebase SDK или нативный SDK) и получает **ID‑token**.
2. Клиент отправляет на backend запрос вида «auth через соцсеть»:
   - `idToken` (Firebase ID token);
   - `authType = REGISTER` (явно указано, что это регистрация, а не логин);
   - дополнительные поля регистрации (возраст, как чувствует себя, соцсети, онбординг, стартовые активности и т.п.).
3. **Бэкенд** через интеграционный слой (FirebaseService) проверяет валидность ID‑токена и получает профиль пользователя у провайдера (email, имя, UID, флаг `emailVerified` и т.д.).
4. По email (или UID) выполняется поиск пользователя в локной БД:
   - если пользователь **уже есть, но был создан по email/паролю** (нет привязки к Firebase) — возвращается ошибка: «email уже используется обычной учётной записью, войдите по email/паролю»;
   - если пользователь **не найден** — это новый пользователь, продолжаем регистрацию.
5. Создаётся новый пользователь в БД:
   - email из внешнего профиля;
   - `firebaseUid` (UID из Firebase) или аналогичный идентификатор;
   - `emailVerified` берётся из данных провайдера (если провайдер уже верифицировал email);
   - роли по умолчанию (`user`);
   - дополнительные поля регистрации (возраст, начальное состояние, соцсети, онбординг и т.п.).
   - локальный пароль при этом не нужен и не задаётся.
6. При необходимости создаются стартовые сущности (например, временные статьи/опросы, стартовые активности) аналогично обычной регистрации.
7. Генерируются **JWT‑токены** (access + refresh), как и для обычного пользователя.
8. В ответе клиент получает:
   - `accessToken`, `refreshToken`;
   - данные пользователя (без чувствительных полей);
   - флаг `isNewUser = true`, по которому клиент понимает, что это была именно регистрация, а не просто вход.

---

### 3. Логин: email + пароль

**Цель:** аутентифицировать уже существующего пользователя по локальному паролю и выдать токены доступа.

**Последовательность:**

1. **Клиент** отправляет на backend:
   - email;
   - пароль.
2. **Бэкенд** ищет пользователя по email:
   - если пользователь не найден — возвращает ошибку «неверные учётные данные» (или аналогичную);
   - если пользователь найден, но `emailVerified = false` — может вернуть ошибку «email не подтверждён» и не выдавать токены.
3. Введённый пароль сравнивается с **хэшом пароля** (bcrypt.compare или аналог).
   - если хэш не совпадает — ошибка аутентификации;
   - если совпадает — вход успешен.
4. Формируется полезная нагрузка JWT (обычно `id`, `email`, `roles`) и генерируются:
   - `accessToken` (короткоживущий);
   - `refreshToken` (долгоживущий).
5. При выходе или принудительном отзыве токенов access/refresh могут добавляться в **чёрный список** (например, в Redis), чтобы досрочно запретить их использование.

---

### 4. Логин: через соцсети (Firebase / OAuth)

**Цель:** выполнить аутентификацию существующего пользователя, ранее зарегистрированного через соцсети, без ввода локального пароля.

**Последовательность:**

1. **Клиент** выполняет авторизацию у провайдера (через Firebase и т.п.) и получает **ID‑token**.
2. Клиент отправляет на backend запрос «auth через соцсеть»:
   - `idToken` (Firebase ID token);
   - `authType = LOGIN` (явно указано, что это сценарий входа, а не регистрации).
3. **Бэкенд**:
   - проверяет токен у провайдера (валидность, срок, подпись);
   - получает профиль (email, UID и др.);
   - ищет по email (и/или UID) пользователя в локной БД.
4. Если пользователь **не найден**, а `authType = LOGIN`:
   - возвращается контролируемая ошибка: «пользователь не найден в базе, нужно сначала пройти регистрацию»;
   - **автоматического создания** пользователя в сценарии логина нет — этим явно отделяется «вход» от «регистрации» через соцсети.
5. Если пользователь найден, но был создан как обычный (email/пароль, без привязки к Firebase):
   - возвращается ошибка вида «этот email уже используется обычной учётной записью, войдите по email/паролю»;
   - таким образом, один и тот же email не может использоваться одновременно как «соцсетевой» и «парольный» для разных типов входа.
6. Если пользователь найден и привязан к соцсети (есть соответствующий UID/флаг):
   - генерируется `accessToken` и `refreshToken` по тому же принципу, что и при обычном логине;
   - в ответ возвращается объект `{ accessToken, refreshToken, user, isNewUser: false }`.
7. При необходимости в этом же потоке могут дополняться вспомогательные данные (например, линковаться подписки по внешнему идентификатору), но с точки зрения авторизации это уже вторичный шаг.
